// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/Policast.sol";
import "../src/PolicastViews.sol";

contract MockERC20 {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    
    constructor() {
        balanceOf[msg.sender] = 10000000 * 1e18;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(allowance[from][msg.sender] >= amount, "Insufficient allowance");
        require(balanceOf[from] >= amount, "Insufficient balance");
        
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }
}

contract ArbitrageExploitTest is Test {
    PolicastMarketV3 public policast;
    PolicastViews public views;
    MockERC20 public token;
    
    function setUp() public {
        token = new MockERC20();
        policast = new PolicastMarketV3(address(token));
        views = new PolicastViews(address(policast));
        
        token.approve(address(policast), type(uint256).max);
    }
    
    function test_ArbitrageExploit() public {
        // Create a 3-option market
        string[] memory options = new string[](3);
        options[0] = "Option A";
        options[1] = "Option B"; 
        options[2] = "Option C";
        
        string[] memory descriptions = new string[](3);
        descriptions[0] = "Description A";
        descriptions[1] = "Description B";
        descriptions[2] = "Description C";
        
        uint256 marketId = policast.createMarket(
            "Exploit Test Market",
            "Test description", 
            options,
            descriptions,
            86400, // 1 day
            PolicastMarketV3.MarketCategory.OTHER,
            PolicastMarketV3.MarketType.PAID,
            10000 * 1e18, // Initial liquidity
            false
        );
        
        policast.validateMarket(marketId);
        
        console.log("=== TESTING ARBITRAGE EXPLOIT ===");
        
        // Check initial balance
        uint256 initialBalance = token.balanceOf(address(this));
        console.log("Initial balance:", initialBalance / 1e18);
        
        // Check initial prices - should be 33.33 each
        uint256 priceA = views.calculateCurrentPrice(marketId, 0);
        console.log("Initial price A:", priceA / 1e18, "tokens");
        
        // Buy 1000 shares at 33.33 tokens each
        console.log("=== Buying 1000 shares of Option A ===");
        uint256 costFor1000Shares = (priceA * 1000) / 1e18;
        uint256 fee = (costFor1000Shares * 200) / 10000; // 2% fee
        uint256 totalCost = costFor1000Shares + fee;
        console.log("Expected cost for 1000 shares:", totalCost / 1e18, "tokens");
        
        policast.buyShares(marketId, 0, 1000 * 1e18, type(uint256).max, 0);
        
        // Check price after buying
        priceA = views.calculateCurrentPrice(marketId, 0);
        console.log("Price A after buying 1000 shares:", priceA / 1e18, "tokens");
        
        // Check our balance after buying
        uint256 balanceAfterBuy = token.balanceOf(address(this));
        uint256 actualCost = initialBalance - balanceAfterBuy;
        console.log("Actual cost paid:", actualCost / 1e18, "tokens");
        
        // Now try to sell immediately
        console.log("=== Selling 1000 shares immediately ===");
        uint256 expectedProceeds = (priceA * 1000) / 1e18;
        uint256 sellFee = (expectedProceeds * 200) / 10000;
        uint256 netProceeds = expectedProceeds - sellFee;
        console.log("Expected net proceeds:", netProceeds / 1e18, "tokens");
        
        // Get user's shares before selling
        uint256 userShares = policast.getMarketOptionUserShares(marketId, 0, address(this));
        console.log("User shares:", userShares / 1e18);
        
        policast.sellShares(marketId, 0, 1000 * 1e18, 0, 0);
        
        // Check balance after selling
        uint256 finalBalance = token.balanceOf(address(this));
        uint256 actualProceeds = finalBalance - balanceAfterBuy;
        console.log("Actual proceeds from sale:", actualProceeds / 1e18, "tokens");
        
        // Calculate profit/loss
        int256 profitLoss = int256(actualProceeds) - int256(actualCost);
        console.log("=== RESULT ===");
        if (profitLoss > 0) {
            console.log("PROFIT:", uint256(profitLoss) / 1e18, "tokens");
            console.log("ALERT: ARBITRAGE EXPLOIT DETECTED!");
        } else if (profitLoss < 0) {
            console.log("LOSS:", uint256(-profitLoss) / 1e18, "tokens");
        } else {
            console.log("BREAK EVEN");
        }
        
        if (profitLoss >= 0) {
            console.log("Total net change: +", uint256(profitLoss) / 1e18, "tokens");
        } else {
            console.log("Total net change: -", uint256(-profitLoss) / 1e18, "tokens");
        }
        
        // Calculate percentage return
        uint256 absProfit = uint256(profitLoss > 0 ? profitLoss : -profitLoss);
        uint256 percentReturn = (absProfit * 10000) / actualCost;
        console.log("Return percentage:", percentReturn / 100);
        console.log("Decimal:", percentReturn % 100);
        
        // This should NOT be profitable - if it is, the system is exploitable
        if (profitLoss > 1e18) { // More than 1 token profit
            revert("CRITICAL: System allows arbitrage exploitation!");
        }
    }
}